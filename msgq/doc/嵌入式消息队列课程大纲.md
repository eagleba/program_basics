# 嵌入式系统中的轻量级消息队列：原理与实战

## 课程总主题
嵌入式系统中的轻量级消息队列：原理与实战（核心聚焦"嵌入式场景适配"，不贪多，只讲能用、好用的基础）

## 课程设计核心原则
1. **嵌入式场景优先**：所有例子、代码都围绕"MCU/嵌入式Linux"，不用服务器端案例（避免学习者困惑）
2. **基础为王**：先讲"自己实现极简队列"，再讲"用工具"，让学习者先懂原理，再用工具（避免只会用框架，不懂底层）
3. **留扩展空间**：模块四的"问题解决"和"扩展方向"，刚好能衔接你以后想加的"信号量""其他技巧"，不用改整体框架

---

## 01-intro 入门篇

### 01-嵌入式系统痛点分析.md
**目标**：让学习者意识到嵌入式中为什么需要消息队列

**核心痛点**：
- **多任务并发带来的阻塞问题**（任务执行时间差异大）
- **任务间耦合度过高**（直接函数调用）
- **资源竞争**（全局变量多任务访问）
- **数据传输需要缓冲**（突发数据高峰）

**具体场景案例**：
1. **传感器数据上报场景**：温湿度传感器采集任务 + OLED显示任务
2. **按键控制场景**：按键检测任务 + 执行器控制任务
3. **多任务资源竞争**：采集、存储、通信任务同时访问共享资源

**对比分析**：
| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 直接函数调用 | 简单直接 | 耦合度高、阻塞严重 | 简单单任务系统 |
| 全局变量 | 实现简单 | 竞争条件、难调试 | 不推荐 |
| 消息队列 | 解耦、异步、缓冲 | 需要额外内存 | 多任务系统 |

**引出MQ的三大作用**：**解耦、异步、缓冲**

---

### 02-消息队列核心作用（嵌入式场景）.md
**目标**：让学习者记住MQ的核心价值

**三大核心作用**：
- **解耦**：任务之间只通过消息通信，不关心对方实现细节
- **异步**：生产者发送消息后立刻返回，无需等待消费者处理
- **缓冲**：消息在队列中排队，平滑处理突发数据

**嵌入式特有优化**：
- **低内存占用**（队列长度固定、消息大小固定）
- **支持阻塞/非阻塞模式**（满足实时性需求）
- **支持多生产者/多消费者模式**

**与服务器端MQ的区别**：
- 服务器端（如RabbitMQ/Kafka）：高吞吐、高可用、分布式
- 嵌入式端：轻量（占内存小）、实时（低延迟）、资源占用少

---

## 02-principles 原理篇

### 01-消息队列最小组成.md
**目标**：让学习者理解MQ的基本构成

**四个核心组件**：
- **消息（Message）**：数据单元（结构体/字节流）
- **队列（Queue）**：存储消息的缓冲区（FIFO）
- **生产者（Producer）**：发送消息的任务
- **消费者（Consumer）**：接收消息的任务

**工作流程图**：
```
[生产者] → [消息队列] → [消费者]
    ↓           ↓           ↓
  发送消息    缓冲存储    接收处理
```

**嵌入式消息示例**：
```c
typedef struct {
    uint8_t sensor_id;    // 传感器ID
    float value;          // 数据值
    uint32_t timestamp;   // 时间戳
} sensor_message_t;
```

---

### 02-嵌入式关键细节（线程安全/内存控制）.md
**目标**：嵌入式MQ实现的注意事项

**线程安全**：
- 多任务访问队列必须加锁（互斥锁/信号量）
- FreeRTOS中可用`xQueueSend`/`xQueueReceive`（已线程安全）
- 裸机环境需要手动实现锁机制

**内存控制**：
- 固定消息大小和队列长度
- 避免动态内存分配（尤其裸机/MCU）
- 根据设备内存大小合理设置参数

**实时性考虑**：
- **阻塞模式**：队列空/满时阻塞等待
- **非阻塞模式**：立即返回，适合实时任务
- **超时模式**：设置等待超时时间

---

### 03-简易队列实现（C语言）.md
**目标**：从零实现一个基础的环形队列

**数据结构定义**：
```c
typedef struct {
    uint8_t *buffer;      // 队列缓冲区
    uint16_t head;        // 队列头指针
    uint16_t tail;        // 队列尾指针
    uint16_t size;        // 队列大小
    uint16_t item_size;   // 单个消息大小
    uint16_t count;       // 当前消息数量
} Queue;
```

**基本操作函数**：
- `queue_init()`：初始化队列
- `queue_enqueue()`：入队
- `queue_dequeue()`：出队
- `queue_is_full()`/`queue_is_empty()`：状态判断
- `queue_get_count()`：获取当前消息数量

**完整实现代码**：见 `examples/02-principles/simple_queue.c`

---

## 03-practice 实战篇

### 01-ZeroMQ嵌入式环境搭建.md
**目标**：在嵌入式Linux/MCU上编译ZeroMQ

**嵌入式Linux环境**：
```bash
# 下载源码
git clone https://github.com/zeromq/libzmq.git
cd libzmq

# 交叉编译
./configure --host=arm-linux-gnueabihf \
            --prefix=/opt/zeromq \
            --disable-shared \
            --enable-static
make && make install
```

**MCU移植方案**：
- **方案1**：使用nanomsg（ZeroMQ的轻量替代）
- **方案2**：使用FreeRTOS内置队列
- **方案3**：自研轻量级MQ

**编译配置**：
- 最小化编译选项
- 静态链接减少依赖
- 禁用不需要的功能

---

### 02-实战1：传感器数据传输.md
**目标**：单生产者-单消费者模型

**项目结构**：
```
sensor_demo/
├── Makefile
├── producer.c      # 生产者（传感器采集）
├── consumer.c      # 消费者（OLED显示）
├── common.h        # 公共定义
└── README.md       # 使用说明
```

**生产者代码**：
```c
// producer.c - 温度传感器数据生产者
#include "common.h"

int main() {
    // 初始化ZeroMQ
    void *context = zmq_ctx_new();
    void *socket = zmq_socket(context, ZMQ_PUSH);
    zmq_connect(socket, "tcp://localhost:5555");
    
    while(1) {
        // 读取传感器数据
        float temperature = read_temperature_sensor();
        
        // 构造消息
        sensor_message_t msg = {
            .sensor_id = TEMP_SENSOR_ID,
            .value = temperature,
            .timestamp = get_timestamp()
        };
        
        // 发送消息
        zmq_send(socket, &msg, sizeof(msg), 0);
        
        // 延时
        delay_ms(100);
    }
    
    zmq_close(socket);
    zmq_ctx_destroy(context);
    return 0;
}
```

**消费者代码**：
```c
// consumer.c - OLED显示消费者
#include "common.h"

int main() {
    // 初始化ZeroMQ
    void *context = zmq_ctx_new();
    void *socket = zmq_socket(context, ZMQ_PULL);
    zmq_bind(socket, "tcp://*:5555");
    
    while(1) {
        sensor_message_t msg;
        
        // 接收消息
        zmq_recv(socket, &msg, sizeof(msg), 0);
        
        // 显示到OLED
        oled_display_temperature(msg.value);
        
        // 打印调试信息
        printf("Received: Sensor=%d, Temp=%.2f, Time=%u\n", 
               msg.sensor_id, msg.value, msg.timestamp);
    }
    
    zmq_close(socket);
    zmq_ctx_destroy(context);
    return 0;
}
```

**编译和运行**：
```bash
# 编译
make

# 运行（需要两个终端）
# 终端1：启动消费者
./consumer

# 终端2：启动生产者
./producer
```

---

### 03-实战2：多任务适配（Pub/Sub模式）.md
**目标**：一个生产者，多个消费者

**项目结构**：
```
pub_sub_demo/
├── Makefile
├── publisher.c     # 发布者（传感器数据）
├── subscriber1.c   # 订阅者1（OLED显示）
├── subscriber2.c   # 订阅者2（蓝牙发送）
├── common.h
└── README.md
```

**发布者代码**：
```c
// publisher.c - 传感器数据发布者
#include "common.h"

int main() {
    void *context = zmq_ctx_new();
    void *socket = zmq_socket(context, ZMQ_PUB);
    zmq_bind(socket, "tcp://*:5556");
    
    // 等待订阅者连接
    sleep(1);
    
    while(1) {
        sensor_message_t msg = {
            .sensor_id = TEMP_SENSOR_ID,
            .value = read_temperature_sensor(),
            .timestamp = get_timestamp()
        };
        
        // 发布消息
        zmq_send(socket, &msg, sizeof(msg), 0);
        delay_ms(1000);
    }
    
    zmq_close(socket);
    zmq_ctx_destroy(context);
    return 0;
}
```

**订阅者代码**：
```c
// subscriber1.c - OLED显示订阅者
#include "common.h"

int main() {
    void *context = zmq_ctx_new();
    void *socket = zmq_socket(context, ZMQ_SUB);
    zmq_connect(socket, "tcp://localhost:5556");
    zmq_setsockopt(socket, ZMQ_SUBSCRIBE, "", 0);  // 订阅所有消息
    
    while(1) {
        sensor_message_t msg;
        zmq_recv(socket, &msg, sizeof(msg), 0);
        
        // 显示到OLED
        oled_display_temperature(msg.value);
        printf("OLED: Displayed temp %.2f\n", msg.value);
    }
    
    zmq_close(socket);
    zmq_ctx_destroy(context);
    return 0;
}
```

**编译和运行**：
```bash
# 编译
make

# 运行（需要三个终端）
# 终端1：启动发布者
./publisher

# 终端2：启动OLED订阅者
./subscriber1

# 终端3：启动蓝牙订阅者
./subscriber2
```

---

## 04-advanced 扩展篇

### 01-常见问题解决方案.md
**消息丢失问题**：
- **原因**：网络中断、队列满、程序崩溃
- **解决方案**：
  - 增加确认机制（ACK）
  - 持久化到Flash/SD卡
  - 重发机制

**延迟问题**：
- **原因**：队列积压、处理速度慢
- **解决方案**：
  - 优化队列大小
  - 使用非阻塞模式
  - 增加处理线程

**内存溢出**：
- **原因**：消息积压、内存泄漏
- **解决方案**：
  - 限制最大消息数
  - 固定消息大小
  - 定期清理过期消息

---

### 02-后续扩展方向.md
**技术扩展**：
- 结合**信号量**控制任务同步
- 实现**自定义轻量MQ**（适配极端资源受限环境）
- 探索其他通信模式（Request-Reply、Pipeline）

**应用扩展**：
- IoT设备间通信
- 嵌入式集群管理
- 实时控制系统

**性能优化**：
- 零拷贝技术
- 内存池管理
- 批量处理优化

---

## 学习路径建议

1. **理论学习**：先理解消息队列的基本概念和嵌入式场景的特殊需求
2. **动手实践**：从简单的环形队列实现开始，逐步过渡到ZeroMQ
3. **项目实战**：完成传感器数据传输项目，理解生产者-消费者模式
4. **扩展应用**：尝试多任务场景，解决实际问题

## 下一步计划

1. 为每个章节准备**完整的示例代码**和**编译脚本**
2. 设计**课后练习**，帮助学习者巩固知识
3. 制作**课程首页**，方便展示学习路径
4. 添加**调试技巧**和**故障排除**指南
